I"<h2 id="前言">前言</h2>

<p>原文写的挺好的,我决定节选一部分过来</p>

<p>节选自<a href="https://segmentfault.com/a/1190000005132717#articleHeader0">Golang服务器的网络层实现</a></p>

<h2 id="传统语言的网络层处理">传统语言的网络层处理</h2>
<p>服务需要同时服务N个客户端，所以传统的编程方式是采用IO复用，这样在一个线程中对N个套接字进行事件捕获，当读写事件产生后再真正<code class="highlighter-rouge">read()</code>或者<code class="highlighter-rouge">write()</code>，这样才能提高吞吐：</p>

<p><img src="/img/in-post/golang-network/2016-05-16-golang-network-00.jpg" alt="image" /></p>

<p>上图中：</p>

<p>绿色线程为接受客户端TCP链接的线程，使用阻塞的调用<code class="highlighter-rouge">socket.accept()</code>，当有新的连接到来后，将<code class="highlighter-rouge">socket</code>对象conn加入IO复用队列。</p>

<p>紫色线程为IO复用的阻塞调用，通常采用<code class="highlighter-rouge">epoll</code>等系统调用实现IO复用。当IO复用队列中的任意<code class="highlighter-rouge">socket</code>有数据到来，或者写缓冲区空闲时可触发<code class="highlighter-rouge">epoll</code>调用的返回，否则阻塞<code class="highlighter-rouge">epoll</code>调用。数据的实际发送和接收都在紫色线程中完成。所以为了提高吞吐，对某个<code class="highlighter-rouge">socket</code>的<code class="highlighter-rouge">read</code>和<code class="highlighter-rouge">write</code>都应该使用非阻塞的模式，这样才能最大限度的提高系统吞吐。例如，假设正在对某个<code class="highlighter-rouge">socket</code>调用阻塞的<code class="highlighter-rouge">write</code>，当数据没有完全发送完成前，<code class="highlighter-rouge">write</code>将无法返回，从而阻止了整个<code class="highlighter-rouge">epoll</code>进入下一个循环，如果这个时候其他的<code class="highlighter-rouge">socket</code>有读就绪的话，将无法第一时间响应。所以非阻塞的读写将在某个fd读写较慢的时候，立刻返回，而不会一直等到读写结束。这样才能提高吞吐。然而，采用非阻读写将大大提高编程难度。</p>

<p>紫色线程负责将数据进行解码并放入队列中，等待工作线程处理；工作线程有数据要发送时，也将数据放入发送队列，并通过某种机制通知紫色线程对应的<code class="highlighter-rouge">socket</code>有数据要写，进而使得数据在紫色线程中写入<code class="highlighter-rouge">socket</code>。</p>

<p>这种模型的编程难度主要体现在：</p>

<ol>
  <li>线程少（也不能太多），导致一个线程需要处理多个描述符，从而存在对描述符状态的维护问题。甚至，业务层面的会话等都需要小心维护</li>
  <li>非阻塞IO调用，使描述符的状态更为复杂</li>
  <li>队列的同步处理</li>
</ol>

<h2 id="golang如何实现网络层">Golang如何实现网络层</h2>

<p>通过参考多个Golang的开源程序，笔者得出的结论是：肆无忌惮的用goroutine吧。于是一个Golang版的网络模型大致是这样的：</p>

<p><img src="/img/in-post/golang-network/2016-05-16-golang-network-01.jpg" alt="image" /></p>

<p>上图是单个客户端连接的服务器模块结构，同样的一个颜色代表一个协程：</p>

<p>绿色goroutine依然是接受TCP链接</p>

<p>当完成握手<code class="highlighter-rouge">accept</code>返回<code class="highlighter-rouge">conn对象</code>后，使用一个单独的<code class="highlighter-rouge">goroutine</code>来阻塞读（紫色），使用一个单独的goroutine来阻塞写（红色）</p>

<p>读到的数据通过解码后放入读<code class="highlighter-rouge">channel</code>，并由蓝色的<code class="highlighter-rouge">goroutine</code>来处理</p>

<p>需要写数据时，蓝色的goroutine将数据写入写<code class="highlighter-rouge">channel</code>，从而触发红色的<code class="highlighter-rouge">goroutine</code>编码并写入<code class="highlighter-rouge">conn</code></p>

<p>可以看到，针对一个客户端，服务端至少有3个<code class="highlighter-rouge">goroutine</code>在单独为这个客户端服务。如果从线程的角度来看，简直是浪费啊，然而这就是协程的好处。这个模型很容易理解，因为跟人们的正常思维方式是一致的。并且都是阻塞的调用，所以无需维护状态。</p>

<p>再来看看多个客户端的情况：</p>

<p><img src="/img/in-post/golang-network/2016-05-16-golang-network-02.jpg" alt="image" /></p>

<p>在多个客户端之间，虽然用了相同的颜色表示goroutine，但实际上他们都是独立的goroutine，可以想象goroutine的数量将是惊人的。然而，根本不用担心！这样的应用程序可能真正的线程只有几个而已。</p>
:ET