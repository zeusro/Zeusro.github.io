## Общие команды

```bash
iftop -i eth0 -nNB -m 10M
```

![image](/img/in-post/ss/1.png)

Просмотр количества соединений в разных состояниях

```bash
netstat -an | awk '/^tcp/ {++y[$NF]} END {for(w in y) print w, y[w]}'
```

```bash
[root@dddd ~]# ss  -s

Total: 9599 (kernel 9688)
TCP:   12227 (estab 26, closed 12043, orphaned 6, synrecv 0, timewait 4920/0), ports 0

Transport Total     IP        IPv6
*         9688      -         -
RAW       0         0         0
UDP       14        8         6
TCP       184       35        149
INET      198       43        155
FRAG      0         0         0
```

Это показывает много соединений в состоянии `closed`.

Состояние `closed` только означает, что соединение вернулось в свое начальное состояние. Этот сокет все еще используется, поэтому, если программе нужно общаться позже, она продолжит использовать этот сокет без перераспределения, что повышает эффективность. В противном случае повторное создание и уничтожение сокетов принесет много накладных расходов.


## Дополнительные знания

net.ipv4.tcp_retries2

По умолчанию 15, что означает, что система Linux будет отслеживать TCP-соединение. Если передачи данных нет, она будет ждать до 15 минут перед освобождением.

Это означает, что службы PHP генерируют большое количество незакрытых соединений.

Похоже, много соединений в состоянии `TIME_WAIT`.


## Ссылки

1. [Краткое обсуждение предотвращения атак SYN Flood и CC с помощью iptables](https://www.cnblogs.com/harlanzhang/p/6189491.html)
1. [Команда ss и состояния Recv-Q и Send-Q](https://www.cnblogs.com/leezhxing/p/5329786.html)
2. [Одна команда Linux в день (57): команда ss](https://www.cnblogs.com/peida/archive/2013/03/11/2953420.html)
