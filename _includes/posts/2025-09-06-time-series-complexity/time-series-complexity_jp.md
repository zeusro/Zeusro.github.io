アルゴリズムを書くとき、**時間**と**空間**の間でバランスを取る必要があります（時には空間を時間と交換し、時には時間を空間と交換します）。

![image](/img/p/dont_move.gif)

しかし、この考え方は実際の実行状況を考慮していません。美しく見えるプログラムを書いたかもしれませんが、実際には意味がなく、まったく実行できません。
したがって、プログラムに対して観測可能な定量的分析を実行し、時間を通じてプログラムの正確性を総合的にテストする必要があります。

アルゴリズム効率を測定する「最後の1キロメートル」を完成させるために、「時系列複雑度」と「単位時系列複雑度」の概念を提案します。

## 従来の時間空間複雑度

**時間複雑度**（Time Complexity）は、アルゴリズムの実行に必要な時間と入力サイズの関係を記述します。

一般的に、O(1) < O(\log n) < O(n) < O(n\log n) < O(n^2) < O(2^n) < O(n!)

**空間複雑度**（Space Complexity）は、アルゴリズムの実行中に必要なメモリ空間と入力サイズの関係を記述します。
主にアルゴリズムのメモリリソースの消費を反映します。

一般的な空間複雑度：
- O(1)：定数の追加変数のみを使用、例：2つの数値を交換
- O(n)：入力サイズと同じ長さの配列を割り当てる必要がある、例：BFSキュー
- O(n^2)：2次元行列を格納
- O(n \log n)：マージソート時の補助配列
- O(n!)：すべての順列結果を格納

## 時系列複雑度

**時系列複雑度**（Time Series Complexity）は、時間複雑度と空間複雑度を満たす前提の下で、アルゴリズムの実行の実際の時間とメモリリソースの利用効率を記述します。

時系列複雑度は2次元チャートです。X軸はt、Y軸は`(used - buff/cache) / total`

時系列複雑度は、プログラムの観測可能な分析を必要とします。個人的には指数減衰型を好みます。

//oracle: 2次元座標系を描画し、横軸をt、Y軸を(used - buff/cache) / totalとし、第1象限のみが必要で、ムーアの法則をシミュレートする指数成長の例と、対応する指数減衰チャートを含む。

![img](/img/time/Time-Series-Complexity.png)

## O(1)「AI」

時系列複雑度のこの概念は、従来の時間空間アルゴリズム複雑度の浅い優劣の問題を突破します。わかりやすく言えば、愚かに見えるプログラムを使用してAIをシミュレートできます。この「AI」が人を騙すことができる限り（チューリングテストに合格）。

```go
package main

import "fmt"

func main() {
    fmt.Println("あなた：こんにちは、AI、元気ですか？")
    aiReply("こんにちは、AI、元気ですか？")
}

func aiReply(input string) {
    if input == "こんにちは、AI、元気ですか？" {
        fmt.Println("AI：元気です、ありがとう！あなたは？")
        if true { // 人が続けて尋ねる
            fmt.Println("あなた：私も元気です、ジョークを言えますか？")
            if true { // AIが答える
                fmt.Println("AI：もちろん！冷たいジョークと熱いジョーク、どちらを聞きたいですか？")
                if true { // 人が選択
                    fmt.Println("あなた：冷たいジョークをください。")
                    if true { // AIが出力
                        fmt.Println("AI：なぜコンピュータは冷たいのですか？常に冷たいデータを処理しているからです！")
                        if true { // 人が続ける
                            fmt.Println("あなた：ハハ、他には？")
                            if true {
                                fmt.Println("AI：はい、なぜAIは夏が嫌いなのですか？ホットモデルに訓練されることを恐れているからです！")
                                if true {
                                    fmt.Println("あなた：とても面白い、自分でジョークを言えますか？")
                                    if true {
                                        fmt.Println("AI：うーん……考えさせてください……プログラマーが最も恐れるものは何だと思いますか？")
                                        if true {
                                            fmt.Println("あなた：何ですか？")
                                            if true {
                                                fmt.Println("AI：無限ループに閉じ込められること！")
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
```

このプログラムは、従来の時間空間アルゴリズムに従って計算すると、O(1)です。

または別の考え方として、10年前のAndroid携帯電話を使用して自分を証明することも、お父さんに10億円を求めて超強力なGPUを搭載したXeonサーバーを購入し、1+1=2を計算することもできます。これは個人的な選択であり、正誤の問題ではありません。

## 偽AI電話

```go
package main

import (
	"fmt"
	"time"
)

// 固定スクリプト
var script = []string{
	"こんにちは、こちらはXX銀行インテリジェントカスタマーサービスセンターです。",
	"最近、年利3.5%という超低金利の信用ローン商品を発売しました。",
	"担保不要、最短30分で融資可能、資金繰りに最適です。",
	"具体的な申請プロセスについて知りたいですか？",
	"お客様の個人状況に応じて、最高50万円の信用枠を提供できます。",
	"申請プロセス全体がオンラインで、非常にシンプルで便利です。",
	"ご興味があれば、専属のアカウントマネージャーを手配して連絡させることができます。",
	"お電話ありがとうございました。当社のローン商品がお役に立てれば幸いです！",
}

func fakeLoanCall() {
	fmt.Println("📞 ダイヤル中...")
	time.Sleep(time.Second * 2)
	fmt.Println("AI：ピーピーピー……接続成功！")

	for _, line := range script {
		time.Sleep(time.Second * 2)
		fmt.Println("AI：", line)

		// ユーザーの反応をシミュレート
		time.Sleep(time.Second)
		fmt.Println("あなた：うーん……わかりました。")
	}
	fmt.Println("📞 通話終了、偽AI電話マーケティングシステムをご利用いただきありがとうございました。")
}

func main() {
	fakeLoanCall()
}
```

```phone
📞 ダイヤル中...
AI：ピーピーピー……接続成功！
AI：  こんにちは、こちらはXX銀行インテリジェントカスタマーサービスセンターです。
あなた：  うーん……わかりました。
AI：  最近、年利3.5%という超低金利の信用ローン商品を発売しました。
あなた：  うーん……わかりました。
AI：  担保不要、最短30分で融資可能、資金繰りに最適です。
あなた：  うーん……わかりました。
AI：  具体的な申請プロセスについて知りたいですか？
あなた：  うーん……わかりました。
AI：  お客様の個人状況に応じて、最高50万円の信用枠を提供できます。
あなた：  うーん……わかりました。
AI：  申請プロセス全体がオンラインで、非常にシンプルで便利です。
あなた：  うーん……わかりました。
AI：  ご興味があれば、専属のアカウントマネージャーを手配して連絡させることができます。
あなた：  うーん……わかりました。
AI：  お電話ありがとうございました。当社のローン商品がお役に立てれば幸いです！
あなた：  うーん……わかりました。
📞 通話終了、偽AI電話マーケティングシステムをご利用いただきありがとうございました。
```

多くのコンピュータオタクは、従来のコンピュータの定義に従って問題を考え、分析することを好みます。しかし、問題自体が生活から来ていることを認識していません。

したがって、カゲロウの交配という非常に簡単な例を通じて、「時系列複雑度」の概念を説明できます。

## カゲロウの空中交配

把握：オスがメスに成功して接近した後、細長い前足を使用してメスの胸部をしっかりと把握します。

体位調整：オスはその後、腹部の端にある長い把握器を曲げ、メスの腹部の端をしっかりと固定します。

接続：この時点で、2匹のカゲロウは「オスが上、メスが下」のタンデムポジションを呈し、一緒に飛行します。

授精：接続飛行中、オスのペニスがメスの受精嚢孔に接続し、精包（精嚢）をメスの体内に注入します。交配プロセス全体が完全に飛行中に完了し、数秒から数分まで続きます。

## 単位時系列複雑度

**単位時系列複雑度**（Unit Time Series Complexity）は、アルゴリズム効率を複合測定する細分化された公式です。
メモリの基礎の上に、必要に応じてCPU/GPUを追加します。
アルゴリズムの単位リソース利用効率を測定するために使用されます。

単位時系列複雑度は3次元チャートです。
ただし、3次元チャートは抽象的すぎるため、一般に2つの2次元チャートに次元削減されます。またはY軸をマージして、2次元チャートの2つの曲線にします。

### 単位CPU時系列複雑度

単位CPU時系列複雑度は3次元チャートです。
X軸はt、
Y軸は`(used - buff/cache) / total`、
Z軸は`cpu_load1`。

必要に応じて`load5`と`load15`に置き換えることもできます。

- cpu_load1：過去1分間の平均負荷
- cpu_load5：過去5分間の平均負荷
- cpu_load15：過去15分間の平均負荷

### 単位GPU時系列複雑度

単位GPU時系列複雑度は3次元チャートです。
X軸はt、
Y軸は`(used - buff/cache) / total`、
Z軸は`gpu_utilization`。

または`gpu_utilization`を`gpu_memory_utilization`に置き換えることもできます。

## P学：3秒の真の男

![image](/img/in-post/three-second/free-m.jpg)

TAが3秒しかないと仮定すると、この関数の横軸の区間は[0,3]で、0は相対的な瞬間的な概念で、「今」を表します。

3秒後、`free -m`はゼロに戻り、「一滴も残っていない」ことを意味します。

純粋に時間の観点から分析すると、カゲロウの交配プロセスは非常に効率的です。しかし、私の良い隣人に置き換えると、一般的に泌尿器科に行くことをお勧めします。

彼らのパートナーがあまり醜くない場合、私も一緒に世話を検討できます。

![image](/img/in-post/three-second/forgive.jpg)

## 拡張

Y軸は単位エネルギー消費指標に置き換えることができ、省エネ型スマートビルの計画と建設に使用されます。

縦軸がメモリ利用率であると言うよりも、縦軸がリソースの利用効率を表すと言う方が適切です。

ムーアの法則の限界がどこにあるかを見てみましょう。

## 結論

大鵬が翼を広げ、空が低すぎることを恨む
