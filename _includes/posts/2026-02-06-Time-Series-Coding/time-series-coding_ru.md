Оригинальная статья по библиотеке временных рядов [http://github.com/zeusro/data](http://github.com/zeusro/data) утрачена, поэтому я могу лишь по обрывочным воспоминаниям восстановить часть, касающуюся временных рядов.

Только практика во времени способна проверить корректность программы. Поэтому я предлагаю модель метапрограммирования временных рядов — новую программную парадигму для моделирования реального мира, философию проектирования, не привязанную к языку программирования.

На этой основе вводится **сложность временных рядов**: при соблюдении традиционной временной и пространственной сложности двумерные графики (например, t и утилизация памяти) и даже трёхмерные (с учётом нагрузки CPU/GPU) описывают фактическое время выполнения алгоритма и использование ресурсов.

## Временной ряд

**Временной ряд**: упорядоченный по времени набор данных, фиксирующий изменение состояния одного и того же объекта во времени.  
У временного ряда единственный API — `Watch`. `Watch` по порядку разбивается на интерфейсы `Read` и `Write`.

## Объект временного ряда

У объекта временного ряда время должно быть первым полем и отражаться в функции инициализации.  
Любые данные, порождённые на основе времени, являются данными временного ряда.

```go
type DeadMonkey struct {
	Birth       time.Time
	GoldenStaff []NLine // Золотая дубинка – параметрический отрезок
	m           int     // масштаб потребителей
	n           int     // масштаб алгоритма
	ZeroPoints  []model.Point
	cost        time.Duration
}
```

## Функция временного ряда

У функции временного ряда первым аргументом должно быть время. Первое поле возвращаемого значения должно быть объектом временного ряда.  
Входное и выходное время задают нижнюю и верхнюю временные границы функции.

```go
// NewDeadMonkey
// m боевые объекты
// n число уникальных ресурсов / масштаб алгоритма
func NewDeadMonkey(birth time.Time, m, n int) *DeadMonkey {
	dead := DeadMonkey{
		Birth: birth,
		m:     m,
		n:     n,
	}
	zeroPoints := make([]model.Point, m)
	p0 := model.RandonPoint()
	zeroPoints[0] = p0
	for i := 1; i < m; i++ {
		p1 := model.RandonPoint()
		// Достаточно не совпадать с предыдущей точкой; глобальные повторы игнорируются
		for p1.Compare(zeroPoints[i-1]) {
			p1 = model.RandonPoint()
		}
		zeroPoints[i] = p1
	}
	dead.ZeroPoints = zeroPoints
	return &dead
}

// SleepAndReturnNewTime принимает аргумент времени, случайно «засыпает», затем возвращает актуальное время
func SleepAndReturnNewTime(inputTime time.Time) time.Time {
    // Установить зерно случайности
    rand.Seed(time.Now().UnixNano())

    // Случайная длительность сна от 1 до 5 секунд
    sleepDuration := time.Duration(rand.Intn(5)+1) * time.Second

    // Сон на случайное время
    time.Sleep(sleepDuration)

    // Вернуть текущее время
    return time.Now()
}
```

## Расстояние во временном ряде

Используется составной критерий: время плюс другие условия (например, на 4-мерной сфере можно опираться только на расстояние или на время и формулу Haversine).

## Логирование временного ряда

Содержимое вывода должно быть в формате «время + содержание».

## Сложность временного ряда

Сложность временного ряда (Time Series Complexity): при заданных временной и пространственной сложности — фактическое время выполнения алгоритма и эффективность использования памяти.

Сложность временного ряда изображается двумерным графиком. По оси X — t, по оси Y — `(used - buff/cache) / total`.

По оси Y при необходимости можно использовать другие метрики, например общую загрузку CPU/GPU.

Единичная сложность временного ряда — трёхмерный график. Трёхмерный график слишком абстрактен; его можно свести к двум двумерным или объединить оси Y в две кривые на одном двумерном графике.

**Единичная CPU-сложность временного ряда** — трёхмерный график: ось X — t, ось Y — (used - buff/cache) / total, ось Z — cpu_load1.

**Единичная GPU-сложность временного ряда** — трёхмерный график: ось X — t, ось Y — (used - buff/cache) / total, ось Z — gpu_utilization.

Для сложности временного ряда требуется анализ наблюдаемости программы.

## Пространство временных рядов

Пространство размерности два и выше, состоящее из временных рядов.

В OOOS [https://github.com/zeusro/system](https://github.com/zeusro/system) я буду по возможности применять эту программную парадигму.

Например:
- Алгоритм параллельного пространства-времени с неблокирующим доступом к ограниченным ресурсам ([https://github.com/zeusro/system/blob/main/function/local/n/china/shenzhen/szx/readme.md](https://github.com/zeusro/system/blob/main/function/local/n/china/shenzhen/szx/readme.md))
- Функция Y ([https://github.com/zeusro/system/blob/main/function/local/n/china/shantou/y/y.go#L73](https://github.com/zeusro/system/blob/main/function/local/n/china/shantou/y/y.go#L73))
