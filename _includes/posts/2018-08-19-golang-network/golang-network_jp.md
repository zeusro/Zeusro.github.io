## 前書き

原文がよく書かれていたので、一部を抜粋することにしました。

[Golangサーバーのネットワーク層実装](https://segmentfault.com/a/1190000005132717#articleHeader0)から抜粋

## 従来の言語のネットワーク層処理

サービスはN個のクライアントに同時にサービスを提供する必要があるため、従来のプログラミング方法はIO多重化を使用し、1つのスレッドでN個のソケットのイベントをキャプチャし、読み書きイベントが発生したときに実際に`read()`または`write()`を実行して、スループットを向上させます：

![image](/img/in-post/golang-network/2016-05-16-golang-network-00.jpg)

上図では：

緑色のスレッドはクライアントTCP接続を受け入れるスレッドで、ブロッキング呼び出し`socket.accept()`を使用します。新しい接続が到着すると、`socket`オブジェクトconnがIO多重化キューに追加されます。

紫色のスレッドはIO多重化のブロッキング呼び出しで、通常`epoll`などのシステム呼び出しを使用してIO多重化を実装します。IO多重化キュー内の任意の`socket`にデータが到着するか、書き込みバッファが空になると、`epoll`呼び出しが戻り、それ以外の場合は`epoll`呼び出しがブロックします。データの実際の送受信は紫色のスレッドで完了します。スループットを向上させるために、`socket`の`read`と`write`は非ブロッキングモードを使用する必要があります。これにより、システムのスループットが最大化されます。たとえば、`socket`でブロッキング`write`を呼び出しているとします。データが完全に送信される前に、`write`は戻ることができず、`epoll`全体が次のループに入るのを防ぎます。この時点で他の`socket`が読み取り準備完了の場合、すぐに応答できません。したがって、非ブロッキングの読み書きは、fdの読み書きが遅い場合にすぐに戻り、読み書きが完了するまで待機しません。これによりスループットが向上します。ただし、非ブロッキングの読み書きを使用すると、プログラミングの難易度が大幅に向上します。

紫色のスレッドは、データをデコードしてキューに入れ、ワーカースレッドが処理するのを待機する役割を果たします。ワーカースレッドに送信するデータがある場合、データを送信キューに入れ、何らかのメカニズムを通じて紫色のスレッドに、対応する`socket`に書き込むデータがあることを通知し、データが紫色のスレッドで`socket`に書き込まれるようにします。

このモデルのプログラミングの難しさは、主に以下に反映されます：

1. スレッドが少ない（多すぎてもいけない）ため、1つのスレッドが複数の記述子を処理する必要があり、記述子の状態の維持に問題があります。さらに、ビジネスレベルのセッションも慎重に維持する必要があります。
1. 非ブロッキングIO呼び出しにより、記述子の状態がより複雑になります
1. キューの同期処理

## Golangがネットワーク層を実装する方法

複数のGolangオープンソースプログラムを参照して、著者の結論は：goroutineを無制限に使用することです。したがって、Golang版のネットワークモデルはおおよそ次のようになります：

![image](/img/in-post/golang-network/2016-05-16-golang-network-01.jpg)

上図は、単一のクライアント接続のサーバーモジュール構造を示しており、同じ色がコルーチンを表します：

緑色のgoroutineは依然としてTCP接続を受け入れます

ハンドシェイクが完了し、`accept`が`connオブジェクト`を返した後、別の`goroutine`を使用してブロッキング読み取り（紫色）を行い、別のgoroutineを使用してブロッキング書き込み（赤色）を行います

読み取られたデータはデコードされて読み取り`channel`に入れられ、青色の`goroutine`によって処理されます

データを書き込む必要がある場合、青色のgoroutineはデータを書き込み`channel`に書き込み、赤色の`goroutine`がエンコードして`conn`に書き込むようにトリガーします

単一のクライアントに対して、サーバーには少なくとも3つの`goroutine`がこのクライアント専用にサービスを提供していることがわかります。スレッドの観点から見ると、これは無駄ですが、これがコルーチンの利点です。このモデルは理解しやすく、通常の思考方法と一致しているためです。そして、すべての呼び出しがブロッキングであるため、状態を維持する必要はありません。

複数のクライアントの場合を見てみましょう：

![image](/img/in-post/golang-network/2016-05-16-golang-network-02.jpg)

複数のクライアント間で、同じ色を使用してgoroutineを表していますが、実際にはそれらは独立したgoroutineです。goroutineの数が驚異的になることが想像できます。しかし、心配する必要はありません！このようなアプリケーションは、実際のスレッドが数個しかない場合があります。
