## Предисловие

Оригинальная статья была хорошо написана, поэтому я решил выдержать из нее часть.

Выдержка из [Реализация сетевого уровня сервера Golang](https://segmentfault.com/a/1190000005132717#articleHeader0)

## Обработка сетевого уровня в традиционных языках

Сервисам нужно обслуживать N клиентов одновременно, поэтому традиционный подход к программированию — использовать мультиплексирование IO, которое захватывает события для N сокетов в одном потоке, а затем фактически `read()` или `write()`, когда происходят события чтения/записи, чтобы повысить пропускную способность:

![image](/img/in-post/golang-network/2016-05-16-golang-network-00.jpg)

На приведенной выше диаграмме:

Зеленый поток — это поток, который принимает TCP-соединения клиентов, используя блокирующие вызовы `socket.accept()`. Когда приходит новое соединение, объект `socket` conn добавляется в очередь мультиплексирования IO.

Фиолетовый поток — это блокирующий вызов для мультиплексирования IO, обычно реализованный с использованием системных вызовов, таких как `epoll`. Когда любой `socket` в очереди мультиплексирования IO получает данные, или когда буфер записи становится свободным, вызов `epoll` может вернуться, иначе вызов `epoll` блокируется. Фактическая отправка и получение данных завершаются в фиолетовом потоке. Поэтому для повышения пропускной способности `read` и `write` для `socket` должны использовать неблокирующий режим, что максимизирует пропускную способность системы. Например, предположим, что вы вызываете блокирующий `write` на `socket`. Прежде чем данные будут полностью отправлены, `write` не может вернуться, что предотвращает вход всего `epoll` в следующий цикл. Если в это время другие `sockets` готовы к чтению, они не могут ответить немедленно. Поэтому неблокирующее чтение/запись вернется немедленно, когда fd медленно читает/пишет, а не будет ждать завершения чтения/записи. Это повышает пропускную способность. Однако использование неблокирующего чтения/записи значительно увеличивает сложность программирования.

Фиолетовый поток отвечает за декодирование данных и помещение их в очередь, ожидая обработки рабочими потоками. Когда рабочие потоки имеют данные для отправки, они также помещают данные в очередь отправки и уведомляют фиолетовый поток через какой-то механизм, что соответствующий `socket` имеет данные для записи, чтобы данные были записаны в `socket` в фиолетовом потоке.

Сложность программирования этой модели в основном отражается в:

1. Мало потоков (и не слишком много), что заставляет один поток обрабатывать несколько дескрипторов, таким образом существуют проблемы с поддержанием состояния дескриптора. Даже сессии на уровне бизнеса нужно тщательно поддерживать.
1. Неблокирующие вызовы IO делают состояние дескриптора более сложным
1. Синхронная обработка очередей

## Как Golang реализует сетевой уровень

Ссылаясь на несколько программ с открытым исходным кодом Golang, вывод автора: используйте goroutines безрассудно. Таким образом, версия сетевой модели Golang примерно такая:

![image](/img/in-post/golang-network/2016-05-16-golang-network-01.jpg)

Приведенная выше диаграмма показывает структуру модуля сервера для одного клиентского соединения, с тем же цветом, представляющим корутину:

Зеленая goroutine по-прежнему принимает TCP-соединения

После завершения рукопожатия и возврата `conn object` из `accept`, используйте отдельную `goroutine` для блокирующего чтения (фиолетовый), и используйте отдельную goroutine для блокирующей записи (красный)

Прочитанные данные декодируются и помещаются в канал чтения `channel`, и обрабатываются синей `goroutine`

Когда нужно записать данные, синяя goroutine записывает данные в канал записи `channel`, что запускает красную `goroutine` для кодирования и записи в `conn`

Видно, что для одного клиента сервер имеет по крайней мере 3 `goroutines`, обслуживающих этого клиента отдельно. Если рассматривать с точки зрения потока, это расточительно, но это преимущество корутин. Эта модель легко понять, потому что она согласуется с нормальным мышлением. И все вызовы блокирующие, поэтому нет необходимости поддерживать состояние.

Давайте посмотрим на случай нескольких клиентов:

![image](/img/in-post/golang-network/2016-05-16-golang-network-02.jpg)

Среди нескольких клиентов, хотя используется тот же цвет для представления goroutines, они фактически являются независимыми goroutines. Можно представить, что количество goroutines будет поразительным. Однако не нужно беспокоиться! Такое приложение может иметь только несколько фактических потоков.
