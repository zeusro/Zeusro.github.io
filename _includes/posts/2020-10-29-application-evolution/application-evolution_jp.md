[kube-killer](https://github.com/p-program/kube-killer/blob/master/README_ZH.md)の中国語ドキュメントで、私はアプリケーションアーキテクチャの進化プロセスを簡単に紹介しました。

今日、私はより高いレベルから、複数の次元でアプリケーションアーキテクチャの進化プロセスを説明することにしました。

## ビジネス次元

### 大きな黄色いアヒル

![image](/img/in-post/application-evolution/1.png)

`docker`がリリースされる前、コンテナ技術は実際に何年も探索されてきました。実際、`Java`という言語はコンテナ化技術です。この不器用な言語がこれほど輝いたのは、仮想化を通じてオペレーティングシステムとハードウェアの違いを無視したためです。`Java`と競合するC#は、Microsoftが独自の`windows server`を宣伝したかったため、プラットフォームに強くバインドされています。

では、無料の`Linux`システムがあるのに、なぜ`windows server`システムが必要なのでしょうか？だから`Java`は本質的にC#に対して次元削減攻撃を行ったのです。

言語はビジネス価値を実現するためのツールです。古代では、アプリケーションアーキテクチャはモノリシックアプリケーションにより傾いていました。このモノリシックアプリケーションには、Webプログラム全体に必要なすべてのロジックが含まれていました。

企業の発展はビジネスにあり、ビジネスの発展は外向きの円です。だから多くのウェブサイトは最終的に巨大な航空母艦になりました。

### 黄色いアヒルがしぼんだ

![image](/img/in-post/application-evolution/2.png)

ビジネスが拡大するにつれて、対応するソースコードも拡大しました。チェックインとチェックアウトがますます頻繁になり、コードマージのたびに悪夢でした。だからこの時点で、モノリシックアプリケーションの欠点が現れ始めました。開発もデプロイも巨大なエンジニアリングの課題になりました。

だからこの時点で、小さな黄色いアヒルはしぼみました。

しぼんだ後はどうすればよいでしょうか？結論は分割です。

### 小さなアヒルになる

![image](/img/in-post/application-evolution/3.png)

ビジネス次元での分割はサービスガバナンスと呼ばれます。実際、10年前にこの考え方がありました。当時はSOAと呼ばれていました。Microsoftのシステムは`WCF`と呼ばれていました。当時、`JAVA`プログラムが`WCF`サービスにアクセスする方法をオンラインで尋ねる人が時々いました。それが実際にはサービスガバナンスの原型でした。

私の見解では、近年のマイクロサービスの誇大宣伝は単に新瓶に古い酒を詰めただけです。根本的な考え方は根本的に変わっていません。しかし、言い換えれば、ビジネスの分割の効果は顕著です—各モジュールの人は自分のビジネスに集中するだけで済みます。

## 運用次元

運用次元から見ると、アプリケーションデプロイメントモデルは少し異なります。

### 百家争鳴の時代

この時代、さまざまな言語が交代で登場しました。運用担当者として、常に`Windows Server`、`Centos`、`Ubuntu`プラットフォーム間の違いを自分でマスターする必要がありました。さらに悪いことに、言語自体も絶えず発展しており、複数のバージョンの言語が互いに戦うことがありました。

![image](/img/in-post/application-evolution/middle-finger.jpg)

ソフトウェアレベルを超えて、ハードウェアレベルも問題です。さまざまなハードウェアメーカーは独占を作りたいので、自分だけが持つものを作り、特許を申請し、「技術革新」と呼んで顧客に販売します。しかし、運用の観点から見ると、この差異は非常に苦痛です。

さらに、ハードウェアとソフトウェアの間にはアクセス層が必要で、これはドライバーと呼ばれます。一部のハードウェアメーカーは特定のオペレーティングシステムでドライバーを作るのが面倒なので、NVIDIAはLinusの世界的に有名な中指を受け取りました。

### Javaコンテナ時代

![image](/img/in-post/application-evolution/Java.png)

Javaがこれほど人気がある理由は、オペレーティングシステムの上に別の抽象化レイヤーを追加し、この抽象化を通じてプラットフォームの違いを排除したためです。だから私は常に強調してきましたが、`Java`は本質的にコンテナ技術であり、言語ではありません。

では、1台のサーバーで複数の`Java`プログラムを実行したい場合、どうすればよいでしょうか？

### Dockerコンテナ時代

これが`docker`コンテナがさらに優れている点です—「システム」自体を抽象化します。このレベルでは、任意のプログラムを許可でき、マシン上の他のプログラムにまったく影響を与えません。

`docker`イメージのコンテキストでは、「システム」は読み取り専用ファイルの束にすぎず、プログラムは上部の読み書き可能な「ファイル」レイヤーです。`docker`の出現により、単一のマシンで複数のバージョンの`Java`プログラムを実行することが可能になり、その設計の巧妙さは、コンテナ間の環境が「分離されている」（実際にはサーバーリソースは分離できませんが）ことです。その分離とは、仮想環境内で好きなソフトウェアをインストールしても、他のコンテナに影響を与えないことを意味します。

この時点で、運用は開発に言うだけです：「イメージをください。何をくれても、docker runで実行するだけです。」

### Serverless時代

私は以前、「[広州地下鉄](http://www.bullshitprogram.com/guangzhou-metro/)」という記事で言いました：

> 現在のWebは、Serverlessの特殊なケースにすぎません（非常に長寿命のServerless）

連続性は不連続性の特殊な状態です。ほとんどの人はこれを認識できていません。

`Serverless`時代では、コンテナは実際には急速に生まれ死ぬ一時的なアーキテクチャです。これは実際に`DevOps`エンジニアに新しい要求を課します—この全く新しいアーキテクチャに適応するために、監視とログシステムをうまく設計する必要があります。

## パブリッククラウド次元

パブリッククラウドの観点から見ると、別の興味深い光景が見えます。

### ブラックインターネットカフェ時代

ブラックインターネットカフェ時代、パブリッククラウドは`Xen`または`KVM`仮想化を通じて実際の物理マシンを分割し、課金ルールを追加してからユーザーに販売しました。

パブリッククラウドは実際に常に「オーバーセール」メカニズムを持っています。彼らはあなたに2コア4Gを販売します。実際、分割された仮想環境をあなたにレンタルしています。物理マシンの実際の構成は96コア196Gですが、販売された「サーバー」構成の合計は200コア400Gかもしれません。

オーバーセールは合理的です。なぜなら、ほとんどのサーバーロードは規則的で、24時間フル容量で実行することはできないと観察されているためです。だから、ここでの余裕は、オーバーセールメカニズムが機能するための第一原理条件です。

### コンピュートストレージ分離時代

家庭用PCのハードドライブとCPUはすべて同じマザーボード上にあることがわかっています。しかし、パブリッククラウドにとって、これは少し面倒です。ユーザーが2コア4Gのマシンを望むが、ハードドライブが4T必要で、64コア128Gの物理マシン全体に4Tのハードドライブしかない場合、どうすればよいでしょうか？

だから、コンピュートとストレージの分離はトレンドです。より柔軟なアーキテクチャでのみ、ユーザーの多様な選択により適応できるためです。

### 集約的管理時代

`Kubernetes`はコンテナスケジューリングシステムです。マイクロからマクロまで、アプリケーション、サーバー、ネットワーク、その他のコンポーネントを抽象化します。この巨大なオペレーティングシステムは、実際にはパブリッククラウドオペレーティングシステムを再構築することに相当します。

R&Dにとって、私は自分の期待値を設定するだけで、残りは`DevOps`エンジニアに任せます。

`DevOps`エンジニアにとって、それはスムーズなビルドパイプラインを構築し、コードからイメージへのビルドを実装し、イメージからワークロードへのタスクを完了することです。最後に、ワークロードの問題を解決します。

パブリッククラウドにとって、`Kubernetes`が提供するメッセージに基づいて、それに応じてトラブルシューティングできます。パブリッククラウドはサーバーを販売するのではなく、コンピューティングリソースプールを販売します。

### Serverless無サーバー時代

ingress --> service --> deploymentはすでにアプリケーションからWebフロントエンドへの配信を接続しています。パブリッククラウドにとって、もっとシンプルにできるでしょうか？ユーザーにサーバーを販売しなくなり、ユーザーがコンテナを提供してくれれば、アプリケーション全体のリリースを完了できますか？

これが`Serverless`無サーバー時代の素晴らしさです。兄さん、私はサーバーもサービスも販売していませんが、アプリケーションリリースプラットフォームを販売しています。パブリッククラウドは[Cloud Native Application Store](http://www.bullshitprogram.com/one-open-operating-system/)になりました。

さらに、パブリッククラウドにとって、`Serverless`時代にはより大きな利点があります：仮想化のオーバーヘッドを排除します。パブリッククラウドにとって、監視、リソース制限、プロセス分離、課金管理をうまく行えば、超強力な物理マシンで直接プログラムを実行できます。仮想化にはオーバーヘッドがあります。このオーバーヘッドを省略できれば、パブリッククラウド全体の運用効率にとって、実際には非常に大きな改善です。

ただし、これは実際には理想化されたアーキテクチャです。この目標を達成するには、まずコンテナのコンピュートとストレージの分離を完了する必要があります。

## 定期的な不満

![image](/img/in-post/application-evolution/love-java.PNG)

## 参考リンク

[1]
コンテナ技術の発展の簡単な歴史
https://mp.weixin.qq.com/s/RZj26jdw-a_7QErPxOpyrg

[2]
SOAアーキテクチャ設計経験の共有—アーキテクチャ、責任、データの一貫性
https://www.cnblogs.com/wangiqngpei557/p/4486177.html

[3]
Xen V.S. KVMついに完璧な終止符を打つ
https://zhuanlan.zhihu.com/p/33324585

[4]
コンピュートはストレージから分離されるべきか？
https://cloud.tencent.com/developer/article/1619383
