В китайской документации [kube-killer](https://github.com/p-program/kube-killer/blob/master/README_ZH.md) я кратко представил процесс эволюции архитектуры приложений.

Сегодня я решил описать процесс эволюции архитектуры приложений с более высокого уровня, по нескольким измерениям.

## Бизнес-измерение

### Большая жёлтая утка

![image](/img/in-post/application-evolution/1.png)

До выпуска `docker` технология контейнеров фактически исследовалась много лет. На самом деле, `Java` как язык — это технология контейнеризации. Причина, по которой этот неуклюжий язык так ярко сиял, заключается в том, что он игнорировал различия между операционными системами и оборудованием через виртуализацию. C#, который конкурирует с `Java`, сильно привязан к платформе, потому что Microsoft хотела продвигать свой собственный `windows server`.

Итак, раз есть бесплатная система `Linux`, зачем нужна система `windows server`? Так что `Java` по сути выполнила атаку снижения размерности на C#.

Язык — это инструмент для реализации бизнес-ценности. В древние времена архитектура приложений была более склонна к монолитным приложениям. Это монолитное приложение содержало всю логику, необходимую для всей веб-программы.

Развитие предприятия заключается в бизнесе, а развитие бизнеса — это внешний круг. Так что многие веб-сайты в конечном итоге стали огромными авианосцами.

### Жёлтая утка сдулась

![image](/img/in-post/application-evolution/2.png)

По мере расширения бизнеса соответствующий исходный код также расширялся. Проверки и извлечения становились всё более частыми, и каждое слияние кода было кошмаром. Так что на этом этапе недостатки монолитных приложений начали проявляться. И разработка, и развёртывание стали огромными инженерными проблемами.

Так что на этом этапе маленькая жёлтая утка сдулась.

Что делать после сдутия? Вывод — разделение.

### Становление маленькими утками

![image](/img/in-post/application-evolution/3.png)

Разделение в бизнес-измерении называется управлением сервисами. Эта идея фактически существовала 10 лет назад. Тогда это называлось SOA. Система Microsoft называлась `WCF`. Время от времени люди спрашивали в интернете, как программы `JAVA` могут получить доступ к сервисам `WCF`. Это был фактически прототип управления сервисами.

На мой взгляд, шумиха вокруг микросервисов в последние годы — это просто старое вино в новых бутылках. Фундаментальная идея не изменилась принципиально. Но, с другой стороны, эффект разделения бизнеса значителен — люди в каждом модуле должны сосредоточиться только на своём бизнесе.

## Измерение операций

С точки зрения операций, модель развёртывания приложений немного отличается.

### Эра соперничающих школ

В эту эру различные языки по очереди выходили на сцену. Как операционный персонал, вы всегда должны были овладеть различиями между платформами `Windows Server`, `Centos` и `Ubuntu`. Что хуже, сами языки постоянно развиваются, и иногда несколько версий языков сражаются друг с другом.

![image](/img/in-post/application-evolution/middle-finger.jpg)

Помимо программного уровня, аппаратный уровень также является проблемой. Различные производители оборудования хотят создать монополии, поэтому они создают что-то, что есть только у них, подают заявку на патент, называют это "технологическими инновациями" и затем продают клиентам. Но с точки зрения операций, эта дифференциация очень мучительна.

Более того, между оборудованием и программным обеспечением нужен уровень доступа, называемый драйверами. Некоторые производители оборудования слишком ленивы, чтобы делать драйверы для конкретных операционных систем, поэтому NVIDIA получила всемирно известный средний палец Linus.

### Эра контейнеров Java

![image](/img/in-post/application-evolution/Java.png)

Причина, по которой Java так популярна, заключается в том, что она добавила ещё один уровень абстракции поверх операционной системы, устраняя различия платформ через эту абстракцию. Поэтому я всегда подчёркивал, что `Java` по сути является технологией контейнеров, а не языком.

Итак, снова возникает вопрос: если вы хотите запустить несколько программ `Java` на одном сервере, что делать?

### Эра контейнеров Docker

Вот где контейнеры `docker` ещё более блестящи — они абстрагируют саму "систему". На этом уровне вы можете разрешить любую программу, и это вообще не повлияет на другие программы на машине.

"Система" в контексте образов `docker` — это просто набор файлов только для чтения, а программа — это уровень "файлов" для чтения-записи сверху. Появление `docker` сделало возможным запуск нескольких версий программ `Java` на одной машине, и блеск его дизайна заключается в том, что среды между контейнерами "изолированы" (хотя ресурсы сервера фактически не могут быть изолированы). Его изоляция означает, что вы можете установить любое программное обеспечение в своей виртуальной среде, не влияя на другие контейнеры.

На этом этапе операции просто нужно сказать разработке: "Дай мне образ. Что бы ты мне ни дал, мне просто нужно docker run для выполнения."

### Эра Serverless

Я ранее сказал в статье "[Гуанчжоуское метро](http://www.bullshitprogram.com/guangzhou-metro/)":

> Текущий веб — это просто особый случай Serverless (очень долгоживущий Serverless)

Непрерывность — это особое состояние прерывности. Большинство людей не могут это распознать.

В эру `Serverless` контейнеры фактически являются эфемерной архитектурой, которая быстро живёт и умирает. Это фактически предъявляет новые требования к инженерам `DevOps` — им нужно хорошо спроектировать системы мониторинга и логирования, чтобы адаптироваться к этой совершенно новой архитектуре.

## Измерение публичного облака

Если вы стоите с точки зрения публичного облака, вы увидите другую интересную сцену.

### Эра чёрных интернет-кафе

В эру чёрных интернет-кафе публичные облака разделяли фактические физические машины через виртуализацию `Xen` или `KVM`, добавляли правила выставления счетов, а затем продавали их пользователям.

Публичные облака фактически всегда имели механизм "перепродажи". Они продают вам 2 ядра 4G. На самом деле они сдают вам разделённую виртуальную среду. Фактическая конфигурация физической машины — 96 ядер 196G, но общие конфигурации "серверов", проданных, могут быть 200 ядер 400G.

Перепродажа разумна, потому что мы наблюдаем, что большинство нагрузок серверов регулярны и не могут работать на полную мощность 24 часа в сутки. Так что запас здесь — это условие первого принципа для работы механизма перепродажи.

### Эра разделения вычислений и хранения

Мы знаем, что жёсткие диски и процессоры домашних ПК находятся на одной материнской плате. Но для публичных облаков это немного проблематично. Если пользователь хочет машину с 2 ядрами 4G, но нужен жёсткий диск 4T, а вся физическая машина с 64 ядрами 128G имеет только жёсткий диск 4T, что делать?

Так что разделение вычислений и хранения — это тенденция. Потому что только с более гибкой архитектурой мы можем лучше адаптироваться к разнообразному выбору пользователей.

### Эра интенсивного управления

`Kubernetes` — это система планирования контейнеров. От микро до макро она абстрагирует приложения, серверы, сети и другие компоненты. Эта огромная операционная система фактически эквивалентна перестройке операционной системы публичного облака.

Для R&D мне просто нужно установить свои ожидания, а остальное оставить инженерам `DevOps`;

Для инженеров `DevOps` это создание плавного конвейера сборки, реализация сборок от кода к образу, затем выполнение задач от образа к рабочей нагрузке. Наконец, решение проблем рабочей нагрузки;

Для публичных облаков, основываясь на сообщениях, предоставляемых `Kubernetes`, мы можем устранять неполадки соответственно. Публичные облака не продают серверы — они продают пулы вычислительных ресурсов.

### Эра Serverless без серверов

ingress --> service --> deployment уже соединил доставку от приложения к веб-интерфейсу. Для публичных облаков можем ли мы сделать это проще? Больше не продавать серверы пользователям. Пока пользователи доставят мне контейнер, могу ли я завершить весь релиз приложения?

Вот в чём крутость эры `Serverless`. Брат, я не продаю серверы, ни услуги, а платформу релиза приложений. Публичные облака стали [Cloud Native Application Store](http://www.bullshitprogram.com/one-open-operating-system/).

Более того, для публичных облаков эра `Serverless` имеет большее преимущество: устранение накладных расходов виртуализации. Для публичных облаков, пока они хорошо выполняют мониторинг, ограничения ресурсов, изоляцию процессов и управление выставлением счетов, они могут напрямую запускать вашу программу на сверхмощной физической машине. Виртуализация имеет накладные расходы. Если эти накладные расходы можно опустить, это фактически огромное улучшение для общей операционной эффективности публичного облака.

Однако это фактически идеализированная архитектура. Для достижения этой цели нам сначала нужно завершить разделение вычислений и хранения для контейнеров.

## Обычные жалобы

![image](/img/in-post/application-evolution/love-java.PNG)

## Ссылки

[1]
Краткая история развития технологии контейнеров
https://mp.weixin.qq.com/s/RZj26jdw-a_7QErPxOpyrg

[2]
Опыт проектирования архитектуры SOA — Архитектура, Обязанности, Согласованность данных
https://www.cnblogs.com/wangiqngpei557/p/4486177.html

[3]
Xen V.S. KVM Наконец ставит идеальную точку
https://zhuanlan.zhihu.com/p/33324585

[4]
Должны ли вычисления быть отделены от хранения?
https://cloud.tencent.com/developer/article/1619383
