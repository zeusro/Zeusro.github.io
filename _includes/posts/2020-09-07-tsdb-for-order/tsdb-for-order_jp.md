## 面接問題

最近、面接を受けています。ある時、面接官が私にEコマースの秒殺（フラッシュセール）の問題を聞きました。

この問題について、フロントエンドがどれだけ猿真似をしようと（例えば以前のXiaomiのページのように無限ローディング）、どれだけ分散メッセージキュー、マルチレベルキャッシュ、読み書き分離を使おうと、結局データベースが最大のボトルネックになることがわかります。

淘宝商城のダブルイレブンは何年も続いていますが、正直に言うと、毎年クラッシュしています。つまり、Alipayのような優秀なチームでさえ、サービスの可用性には上限があるということです。

## （非）リレーショナルデータベースの解決策

基本的には、データベースの読み書き分離+楽観的ロックまたは悲観的ロックの選択です。

楽観的ロックを使う場合、リアルタイムデータストリームエンジン（メッセージキューコンシューマー）ができるだけ短い時間で無効な注文をカットするようにします。ユーザーが注文を出してから支払いまでの間に、できるだけ無効な注文をフィルタリングします。
俗に「注文カット」と呼ばれます。

悲観的ロックを使う場合、ボトルネックは必ず在庫計算の部分になります。この頻繁に変更されるデータについては、Redis + 定期的なディスク書き込みを推奨します。Redis自体はクラスタ化できるため、可用性の問題を最大限に回避できます。

## 金持ちの解決策

12306はPivotal GemFire分散インメモリコンピューティングプラットフォームを選択しました。

では、時系列データベースでEコマースの注文をどう処理するか？

## 時系列データベースの解決策

以前書いた記事で、私は不変性を時系列データベースの第一属性として確立しました。つまり、時系列データベースには、createとqueryしかなく、updateとdeleteはありません。

したがって、時系列データベース内のすべてのデータは、状態マシンのような存在です。

例えば、商品在庫テーブルは次のようになります：

date|goodID|count
|---|---|---|---|---
2020-09-07 16:00|3| 1
2020-09-07 16:01|3| 0

注文は次のようになります：

date|orderID | userID|goodID|status
|---|---|---|---|---
2020-09-07 16:01|1|2|3| 注文済み
2020-09-07 16:02|1|2|3| 支払い済み

データベース自体は単なるインデックス付きテーブルです。書き込み後、レコードは不変です。データベース自体は不変性を通じてすべてを処理します。

**トランザクションはリアルタイムデータストリーム分析エンジンによって実装されます**。

在庫計算については、このデータをメモリに保持し、リアルタイムデータストリーム分析エンジンがトランザクション計算を完了した後、時系列データベースに書き込むことを推奨します。つまり、時系列データベースには**既に決定された結果**が保存されます。

ただし、この内容については、上記は単なる概念です。ぜひメッセージを残して、一緒に議論しましょう。

## さらなる考察

実際、複雑な技術実装を使うよりも、プロセスを再設計して、超大規模な同時実行の問題を回避する方が良いでしょう。

後期の天猫のダブルイレブンのように、事前にデポジットをロックした注文があります。これらの注文の支払い時間は1時以降です。つまり、アクティビティ設計の最初から、0時の秒殺トラフィックピークをできるだけずらすようにしました。
これは時間と空間を交換するアプローチです。

## 結論

> お金で解決できる問題は問題ではない。

## 参考リンク

[1]
12306ウェブサイト：分散インメモリデータ技術がクエリを75倍高速化
https://cloud.tencent.com/developer/article/1074220

[2]
時系列データベースの重要性
https://zhuanlan.zhihu.com/p/122145626

[3]
時系列データベースこそが未来
http://www.zeusro.com/2020/04/02/tsdb/

[4]
Eコマースウェブサイトで、50W-100Wの高同時実行、秒殺機能はどのように実装されているか？ - 九章算法の回答 - 知乎
https://www.zhihu.com/question/20978066/answer/1415294056
