## Вопрос на собеседовании

Недавно я проходил собеседования. Один раз интервьюер задал мне вопрос о проблеме электронной коммерции с флэш-продажами.

Для этой проблемы, независимо от того, как фронтенд обезьянничает (например, как Xiaomi делала бесконечную загрузку раньше), какие бы распределенные очереди сообщений, многоуровневое кэширование или разделение чтения-записи вы не использовали, в конце концов вы обнаружите, что база данных всегда является самым большим узким местом.

Двойной одиннадцатый день Taobao проводится много лет, но, честно говоря, он падает каждый год. То есть, даже такая отличная команда, как Alipay, имеет верхний предел доступности сервиса.

## Решения (не)реляционных баз данных

В основном это выбор между разделением чтения-записи базы данных + оптимистичной блокировкой или пессимистичной блокировкой.

Если использовать оптимистичную блокировку, то старайтесь сделать так, чтобы движок потоков данных в реальном времени (потребитель очереди сообщений) отсекал недействительные заказы как можно быстрее. Фильтруйте недействительные заказы между размещением заказа пользователем и оплатой.
Обычно это называется отменой заказа.

Если использовать пессимистичную блокировку, то узким местом обязательно будет часть расчета запасов. Для этих часто изменяющихся данных рекомендуется использовать Redis + периодическую запись на диск. Redis сам по себе может быть кластеризован, что максимально избегает проблем с доступностью.

## Решение богача

12306 выбрал платформу распределенных вычислений в памяти Pivotal GemFire.

Итак, как обрабатывать заказы электронной коммерции с помощью базы данных временных рядов?

## Решение базы данных временных рядов

В моей предыдущей статье я установил неизменяемость как первое свойство баз данных временных рядов. То есть, для баз данных временных рядов есть только create и query, нет update и delete.

Таким образом, все данные в базе данных временных рядов существуют как конечный автомат.

Например, таблица запасов товаров выглядит так:

date|goodID|count
|---|---|---|---|---
2020-09-07 16:00|3| 1
2020-09-07 16:01|3| 0

Заказы выглядят так:

date|orderID | userID|goodID|status
|---|---|---|---|---
2020-09-07 16:01|1|2|3| Заказано
2020-09-07 16:02|1|2|3| Оплачено

Сама база данных - это просто индексированная таблица. После записи записи неизменяемы. Сама база данных обрабатывает все через неизменяемость.

**Транзакции реализуются движками анализа потоков данных в реальном времени**.

Для расчетов запасов я предлагаю хранить эти данные в памяти, а затем после того, как движок анализа потоков данных в реальном времени завершит расчеты транзакций, записать их в базу данных временных рядов. То есть, база данных временных рядов хранит **предопределенные результаты**.

Однако, относительно этого содержания, вышеизложенное - это всего лишь концепция. Пожалуйста, оставьте мне сообщение, чтобы обсудить вместе.

## Дальнейшие размышления

На самом деле, вместо использования сложных технических реализаций, лучше перепроектировать процесс, чтобы избежать проблем с массовой конкурентностью.

Как в случае с Double Eleven Tmall позже, будут некоторые заказы с заблокированными депозитами заранее. Время оплаты для этих заказов - после 1 часа ночи. То есть, с самого начала проектирования активности мы старались максимально разнести пик трафика флэш-продажи в 0:00.
Это подход обмена времени на пространство.

## Заключение

> Проблемы, которые можно решить деньгами, не являются проблемами.

## Ссылки

[1]
Сайт 12306: Технология распределенных данных в памяти ускоряет запросы в 75 раз
https://cloud.tencent.com/developer/article/1074220

[2]
Важность баз данных временных рядов
https://zhuanlan.zhihu.com/p/122145626

[3]
Базы данных временных рядов - это будущее
http://www.zeusro.com/2020/04/02/tsdb/

[4]
Как реализована функция флэш-продажи с высокой конкурентностью 50W-100W на сайтах электронной коммерции? - Ответ Jiuzhang Algorithm - Zhihu
https://www.zhihu.com/question/20978066/answer/1415294056
